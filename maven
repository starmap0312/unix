# Maven
  1) generate project (download packages from internet to local repository)
     mvn archetype:generate
     ex.
       mvn archetype:generate -DgroupId=com.myMaven.app -DartifactId=HelloMaven \
       -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false
         -DgroupId: package group Id, ex. com.myMaven.app (organization or company)
         -DartifactId: the project name, i.e. HelloMaven
         -Dversion: project version (default: 1.0-SNAPSHOT)
         -DarchetypeArtifactId: template used to create the project
  2) pom.xml
     information of the package
       <dependency>
           <groupId>com.myMaven.app</groupId>
           <artifactId>HelloMaven</artifactId>
           <version>1.0-SNAPSHOT</version>
       </dependency>
     groupId:artifactId:version specifies a unique package
       a group can have multiple artifacts (projects)
       a artifact (project) can have multiple versions
  3) compile source (at the folder of pom.xml)
     mvn compile
     - HelloMaven
       - pom.xml
       - src
         - main - java - com - myMaven - app - App.java
         - test - java - com - myMaven - app - AppTest.java
       - target (processed data and final package file)
  4) execute program
     mvn exec:java -Dexec.mainClass=com.myMaven.app.App
     App.java
       public class App {
           public static void main(String[] args) {
               System.out.println("Hello Maven!");
           }
       }
  5) create package file
     mvn package
     create .jar file (packaging) based on pom.xml
     create .war file (packaging) based on pom.xml, which will be deployed to Tomcat/JBoss server
  6) clean/remove target folder
     mvn clean
  ex. mvn -DskipTests=true clean package # skip Tests when packaging at target/ folder, ex. target/storm-starter-0.9.3-incubating-SNAPSHOT.jar
  ex. mvn -DskipTests=true clean install # skip Tests when installing package at local repo, ex. ~/.m2/repository/org/apache/storm/

# build the libraries with dependencies
  1) add dependencies in a jar:
     you can put both log4j.jar and jodatime.jar inside the final.jar, but your classes are unable to call other classes which is inside the unpack log4j.jar
     unless you create a special class loader like one-jar plugin, or use maven-assembly-plugin to extract all dependency jars into raw classes, and group it together
  2) with Maven 2, the right way to do this is to use the Maven2 Assembly Plugin which has a pre-defined descriptor file
     just run command:
       mvn assembly:assembly -DdescriptorId=jar-with-dependencie -DskipTests
       (the descriptorId is appended to the built library: ex. mylib-5.54-SNAPSHOT-jar-with-dependencies.jar)

# mvn install
  this installs the developping library to local repo:
    ~/.m2/repository/[groupId]/[artifactId]/[version]/[artifactId]-[version].jar
    ~/.m2/repository/[groupId]/[artifactId]/[version]/[artifactId]-[version].pom
  ex.
    ~/.m2/repository/com/mydomain/myproject/5.54-SNAPSHOT/mylib-5.54-SNAPSHOT.jar
    ~/.m2/repository/com/mydomain/myproject/5.54-SNAPSHOT/mylib-5.54-SNAPSHOT.jar

  then other libaries can put the local repo in the rependency resolver to use the locally installed developping library
  1) add to sbt dependency repo:
     add file "dev.sbt" with the following content:
       resolvers in ThisBuild += "My artifactory Snaps" at "http://artifactory.mydomain.com:4080/artifactory/maven-local-snapshot" # remote snapshot repo
       resolvers in ThisBuild += "Local Maven Repository" at Path.userHome.asFile.toURI.toURL + ".m2/repository"                   # local snapshot repo
       or
       resolvers ++= Seq(
         "My artifactory Snaps" at "http://artifactory.mydomain.com:4080/artifactory/maven-local-snapshot" # remote snapshot repo
         "Local Maven Repository" at "file:///Users/kuanyu/.m2/repository"                                 # local snapshot repo
       )
  2) add to maven dependency repo:
     ???

# Maven Lifecycle
  1) Clean lifecycle
     clean: remove all files generated by the previous build
  2) Default lifecycle
     compile: compile the source code of the project
     test: run tests using a suitable unit testing framework
     package: take the compiled code and package it in its distributable format, ex. .jar
     itegration-test: process and deploy the package if necessary into an environment for running integration test
     install: install the package into the local repository, for use as a dependency in other projects locally
     deploy: copies the final package to the remote repository for sharing with other projects
  3) Site lifecycle
     site: generate the project's site documentation
     site-deploy: deploy the generated site documentation to the specified web server
  ex.
    mvn package
    execute phases: compile, test-compile, test, mvn jar:jar

# commonly execute goals
  1) mvn compile
  2) mvn test
     mvn -Dtest=[TestClass] verify              # run a specific test
     mvn -Dtest=[TestClass]#[testMethod] verify # run a specific test method of a test
  3) mvn package
  4) mvn install: install package into local repository
  5) mvn source:jar: pack the source code into a .jar
  6) mvn jetty:run / mvn tomcat:run: execute web project
  7) mvn javadoc:jar: generate java api .jar file
  8) mvn exec:exec: execute project

# ~/.m2/settings.xml: configuration file
  1) element in the file contains elements used to define values which configure Maven execution in various ways
     ex. values such as the local repository location, alternate remote repository servers, and authentication information
  2) it's like the pom.xml, but should not be bundled to any specific project, or distributed to an audience

# import SNAPSHOT libraries for use of another developing library:
  1) publish the library to be used, mylib_2.11, to remote artifactory of "maven-local-snapshot"
  2) edit the pom.xml of the developing library
       <distributionManagement>
         <snapshotRepository>
           <id>maven-local-snapshot</id> # specify URL of maven-local-snapshot
           <url>scpexe://artifactory-ssh-proxy.mydomain.com:4443/maven-local-snapshot/</url>
         </snapshotRepository>
         <repository>
           <id>maven-local-release</id>
           <url>scpexe://artifactory-ssh-proxy.mydomain.com:4443/maven-local-release/</url>
         </repository>
       </distributionManagement>
       ...
        <dependency>
            <groupId>com.mydomain</groupId>
            <artifactId>mylib_2.11</artifactId>
            <version>0.1.4-SNAPSHOT</version>   # specify version of SNAPSHOT library in dependency
        </dependency>
  3) reimport all Maven libraries to get the latest published SNAPSHOT library
     intellij shortcut: Shift + Cmd + A (click "reimport all Maven libraries")

# maven versions
  square bracket ( [ & ] ) means "closed" (inclusive)
  parenthesis ( ( & ) ) means "open" (exclusive)

  ex. in Maven repository, com.foo:my-foo has the following metadata:

  <?xml version="1.0" encoding="UTF-8"?>
  <metadata>
    <groupId>com.foo</groupId>
    <artifactId>my-foo</artifactId>
    <version>2.0.0</version>
    <versioning>
      <release>1.1.1</release>
      <versions>
        <version>1.0</version>
        <version>1.0.1</version>
        <version>1.1</version>
        <version>1.1.1</version>
        <version>2.0.0</version>
      </versions>
      <lastUpdated>20090722140000</lastUpdated>
    </versioning>
  </metadata>

  1) Declare an explicit version (always resolve to 1.0.1 unless a collision occurs, then maven select a matching one)
     <version>1.0.1</version>
  2) Declare an exact version (always resolve to 1.0.1):
     <version>[1.0.1]</version>
  3) Declare a version range for all 1.x (currently resolve to 1.1.1):
     <version>[1.0.0,2.0.0)</version>
  4) Declare an open-ended version range (resolve to 2.0.0):
     <version>[1.0.0,)</version>

# add 3rd-party dependency
ex. import backtype.storm.LocalCluster; # if storm is not found in the dependencies
    1) add the dependency in pom.xml:
    <dependencies>
        <dependency>
            <groupId>org.apache.storm</groupId>
            <artifactId>storm-core</artifactId>
            <version>0.10.0</version>
            #<scope>provided</scope>            # Use "provided" scope to keep storm out of the jar-with-dependencies (remove this to include the dependency with default scope "compile")
        </dependency>
    </dependencies>
    2) reimport All maven libraries at intellij # resolve the dependencies again
    3) run mvn -DskipTests package              # run packaging the library to verify if the current library can be built

# mvn dependency:tree
mvn dependency:tree: list dependency tree of a maven project
ex. 
[INFO] com.yahoo.nuwa:nuwa-storm-cafeeder:jar:1.5.15-SNAPSHOT
[INFO] +- org.apache.storm:storm-core:jar:0.10.0:provided
[INFO] |  +- com.esotericsoftware.kryo:kryo:jar:2.21:provided
[INFO] |  |  +- com.esotericsoftware.reflectasm:reflectasm:jar:shaded:1.07:provided
[INFO] |  |  |  \- org.ow2.asm:asm:jar:4.0:compile
[INFO] |  |  \- com.esotericsoftware.minlog:minlog:jar:1.2:provided
[INFO] |  +- org.clojure:clojure:jar:1.6.0:provided
[INFO] |  +- com.googlecode.disruptor:disruptor:jar:2.10.4:provided

# Uber JAR: a JAR containing everything
1) an artifact contains only the classes/resources of itself, so Maven will be responsible to find out all artifacts (JARs) that the project depends on when the project is built
2) an uber-jar takes all dependencies and extract the content of the dependencies and put them with the classes/resources of the project itself, in one big JAR
3) it is easy for execution, because you will need only one big JAR instead of many small JARs to run your app

# maven libary shading
1) create uber-jar for ease of deployment is one use case of shade plugin
   ex. 
   problem:

     Qux -> Bar:2.0
         -> Foo -> Bar:1.0

     Foo library depends on a specific version (ex. 1.0) of Bar library and cannot make use of other version of Bar lib (because of API change, etc.)
     Qux project depends on Foo and a newer version Bar:2.0 (because Qux needs to use new feature in Bar:2.0)
     then either Qux using Bar:2.0 or Foo using Bar:1.0 will not work
   solution:
     use shade plugin to rename the usage of Bar:1.0, so that all classes in Bar:1.0 jar are embedded in Foo jar

     Qux -> Bar:2.0
         -> Foo -> Bar:1.0 (shaded, ex. renamed to com.shaded.bar, and embeded in Foo jar)
2) edit pom.xml
    <build>
        <extensions>
            <extension>
                <groupId>org.apache.maven.wagon</groupId>
                <artifactId>wagon-ssh-external</artifactId>
                <version>2.8</version>
            </extension>
        </extensions>
        <plugins>
            <plugin>
                <artifactId>maven-shade-plugin</artifactId>
                <version>2.4.1</version>
                <executions>
                    <execution>
                        <phase>package</phase>
                        <goals>
                            <goal>shade</goal>
                        </goals>
                        <configuration>
                            <relocations>
                                <relocation>
                                    <pattern>net.minidev</pattern>
                                    <shadedPattern>net.minidev.shade</shadedPattern>
                                </relocation>
                            </relocations>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
3) review the built library is indeed shaded
   jar tf target/foo.jar
   
