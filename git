# revert to previous commit and make it a new commit
  git rm -r .           # remove all files
  git checkout HEAD~3 . # path specifier: overwrite all matching files (all files match dot)
  git commit            # make a new commit

# discard unstaged changes of all files
  git checkout .

# git add
  git add -A
  -A, --all: all files in the entire working tree are updated

# git pull: fetch from and integrate with a local branch
  git pull == git fetch origin + git merge origin/master
  git push == git push origin master

# git remote -v: view all remote repos

# push local master branch to a remote origin repo
  git init
  (edit & git commit files)
  git remote add origin git@github.com/OWNER/REPOSITORY.git
  git push origin master (git push -u origin master)

# set up the upstream repo for the remote origin repo
  git clone git@github.com/FORKED_REPO.git
  git remote add upstream https://github.com/ORIGINAL_REPO.git
  sync with upstream
    1) git checkout master       ==> checkout local master branch
    2) git fetch upstream        ==> fetch upstream repo
       git merge upstream/master ==> merge upstream/master to local master branch
       or 
       git pull upstream         ==> git fetch upstream + git merge upstream/master
  (edit & git commit files)
  git push origin master    ==> push local master branch to forked personal GitHub

# git push
  git push origin <branch_name>      => push local branch_name to remote repo)
  git push origin <branch_name> -f   => force push
  git push == git push origin master
  
# create local branch and push to remote
  git checkout -b branch_name
  (create a local branch which is a duplicate of the master branch)
  git push -u origin branch_name
    -u, --set-upstream: for every branch pushed, add upstream (tracking) reference
                        used by argument-less git-pull
    (push local branch to remote)
  git checkout --orphan branch_name
    (create a local and isolated branch)
  git branch -a 
    (-a, --all: list both remote-tracking and local branches)

# create a local branch that tracks a remote branch
  git branch --track branch_name origin/branch_name
  git checkout -b branch_name origin/branch_name
  (create a local branch that tracks a remote branch, and then switch to the local branch)

# delete a branch
  git branch -d <local_branch>
  git push origin --delete <remote_branch> OR git push origin :<remote_branch>

# git fetch: download objects and refs from another repository
  git fetch upstream: fetch original remote repo
  git fetch origin: fetch personal remote repo
  git fetch --all: fetch all remotes (origin and upstream)

# git pull: fetch from and merge with a local branch
  git pull upstream: fetch original remote repo and merge with local branch
  git pull origin: fetch personal remote repo and merge with local branch
  git pull --all: fetch all remotes (origin and upstream) and merge with local branch

# git checkout: switch branches or restore working tree files
  git checkout -f [branch]
  -f, --force: proceed even if the index or the working tree differs from HEAD,
               used to throw away local changes

# git reset: reset current HEAD to the specified state, i.e. change where the HEAD is pointing
  git reset HEAD: unstage all staged modified files
    HEAD: a reference to the last commit in the current branch
  git reset HEAD <filename>: unstage a staged modified file
  git reset --hard HEAD~3: the last 3 versions: HEAD, HEAD^, and HEAD~2 are dropped

# git reset --soft <commit> vs. git reset --hard <commit>

  unstaged  -- (git add) --> staged -- (git commit) --> commited

  ex.
    A - B - C (master)
  git reset --soft B
    HEAD points to B
    git status: staged (the index still has the changes from C, waiting to be commited)
  git reset --mixed B (default)
    HEAD points to B
    git status: unstaged (the index still has the changes from C, waiting to be staged)
  git reset --hard B
    HEAD points to B
    git status: lose changes permanently

  ex.
    git reset --hard HEAD~3
      the last 3 versions: HEAD, HEAD^, and HEAD~2 are dropped

# differences of git fork and clone
  clone: clone a GitHub repo on local workstation
  (need to be declared as a contributor to contribute back to the remote repository,
   need to create a pull request)

  fork:
    1) clone a GitHub repo on the server side, i.e. clone a GitHub repo on your GitHub account
       (can make changes to that forked GitHub repo)
    2) can only contribute to the forked repo
    3) if want to contribute to the upstream (original) repo, you need to create a pull request
       to signal contribution back to the upstream repo
    
    Original (upstream/master)  --> Forked (origin/master)
         |                             |
         ------> Local (master) <-------

# answering a pull request: merge devel branch into master branch
  Step 1)
    git fetch origin
    git checkout -b devel origin/devel
    git merge master
  Step 2)
    git checkout master
    git merge --no-ff devel (no fast-forward when merging)
    git push origin master (update on GitHub)

# show git log graph
  git log --graph --abbrev-commit --decorate

# config user and email
  git config --global user.name "John Doe"
  git config --global user.email johndoe@example.com

# resolve conflicts from command-line
  merge a <remote_branch> of <remote_repo> to the master branch
  1) check out a new branch and test the changes
     git checkout -b <new-branch-for-merge> master                          <== create a new branch for merging
     git pull git@git.com:<git_account>/<remote_repo>.git <remote_branch> <== try to pull the <remote_branch>
     (the pull shows warning messages of conflicts)
  2) edit conflicted files manually and commit the changes
     git commit -am 'resolve the conflicts'
  2) merge the changes to master branch and push the update to GitHub
     git checkout master
     git merge --no-ff <new-branch-for-merge>
     git push origin master

# diff two branches
  git diff <branch1> <branch2>

# git rebase
  ex. git history 
     v1 -> v2 -> v3.1         ... master
           |---> v3.2         ... dev

  1) git checkout dev
  2) git rebase master
     v1 -> v2 -> v3.1         ... master
           |---> v3.1 -> v3.2 ... dev   (need to resolve conflicts if any)

  3) git push origin dev      ... origin/dev (push local dev branch to remote origin/dev)
     git push origin dev -f                  (force push if needed)
  4) create PR to merge orign/dev into upstream/master
  3) git checkout master
     git merge dev OR git pull upstream/master (after the commits are merged into upstream/master)
       v1 -> v2 -> v3.1 -> v3.2 ... master & dev
