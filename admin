# three admin rules
  1) backup everything (and validate the backup) regularly
  2) master the command line (avoid UI if possible)
  3) automate everything

# what is umask?
  umask: user file creation mask, which controls the file permissions when file or directory
    are created
  ex. write umask command in /etc/profile or ~/.bashrc
    umask 022 ==> permissive (default)
      directory permission 755 (rwxr-xr-x), file permission 644 (rw-r--r--)
    umask 026 ==> moderate
      directory permission 751 (rwxr-x--x), file permission 644 (rw-r-----)
    umask 027 ==> moderate
      directory permission 750 (rwxr-x---), file permission 644 (rw-r-----)
    umask 077 ==> severe
      directory permission 700 (rwx------), file permission 600 (rw-------)
  default umask: 022
    i.e. files created users by default are of permissions: 755 (cf. /etc/login.defs)

# troubleshooting using dmesg
  when system boots up, kernel gets loaded into the memory and then kernel controls the entire
    system. the messages about the hardware devices are printed out on the screen and can be
    viewed using dmesg command
  1) view the boot messages: dmesg | more
  2) view avaiable system memory message: dmesg | grep Memory
  3) view Ethernet link status (UP/DOWN): dmesg | grep eth
  4) change the dmesg buffer size: edit /boot/config (change CONFIG_LOG_BUF_SHIFT=18)
  5) clear messages in dmesg buffer: dmesg -c

# rpm package management (Redhat/CentOS)
  rpm: Redhat Package Manager
  1) install an rpm package: rpm -ivh MySQL-client-3.23.57-1.i386.rpm
    (-i: install, -v: verbose, -h: print hash marks when the package is unpacked)
  2) query all rpm packages: rpm -qa
    (-q: query, -a: all installed packages)
  3) upgrade an rpm package: rpm -Uvh MySQL-client-3.23.57-1.i386.rpm
    (like installing, but automatically uninstalling existing version before installing)
  4) uninstall an rpm package: rpm -ev MySQL-client
    (-e: uninstall)
  5) verify all rpm packages: rpm -Va
    (-V: verify, -a: all installed packages)
  6) rebuild corrupted database indices:
     rm /var/lib/rpm/__db*; rpm --rebuilddb

# modprobe: used to add loadable modules to linux kernel, view and remove modules
  linux maintains modules in /lib/modules/$(uname -r)
    the configuration files: /etc/modprobe.conf and /etc/modprobe.d
  1. modprobe -l: list avaiable kernel modules
  2. lsmod: list currently loaded modules
  3. sudo modprobe vmhgfs: install new module vmhgfs into linux kernel
  4. modprobe -r vmhgfs: remove currently loaded module (-r: unload module)

# mount and view ISO files
  ISO: International Organization for Standardization
  ISO files, typically used to distribute operating systems
  mount /path/to/local/file.iso /tmp/mnt -o loop ==> a loop device is a pseudo-device

# chage
  used to manage password expiration and aging
  ex. chage -l username (list the info of password parameters of a user)

# WOL (WakeOnLan): power up server remotely
  1. NIC needs to support WOL feature
  2. enable wakeonlan of NIC: ethtool -s eth0 wol g
  3. install wakeonlan package on another machine: sudo apt-get install wakeonlan
  3. wake up from another machine connected to the same LAN (requires the mac address of NIC)
     wakeonlan 00:16:k5:64:A9:68

# lshw: list hardware spec
  supports html and xml format (lshw -html, lshw -xml)

# ipcs
  IPC (Inter-Process Communication)
  1. pipes: named pipes provide a way for processes running on different computer systems to
     communicate over the network
  2. shared memory: exchange messages in shared memory. one process can create a portion of
     memory which other process can access
  3. message queue: a structured and ordered list of memory segments where processes store or
     retrieve data
  4. semaphores: provide a synchronizing mechanism for processes that are accessing the same
     resource. no data is passed with a semaphore, it simply coordinates access to shared resources
  ipcs -a: list all the IPC facilities which has read access for the current process

# logrotate: manage log files
  rotate the log files, compress the rotated log files, log files with date filenames,
    remove old log files
  edit /etc/logrotate.conf

# ssh
  options -T: Disable pseudo-tty allocation
    do ssh test connection with -T, because some server could abort the transaction entirely
    if a text-terminal (tty) is requested. -T avoids requesting said terminal, since GitHub
    has no intention of giving you an interactive secure shell, where you could type command.
    GitHub only wants to reply to your ssh request, in order to ascertain that the ssh command
    does work (have the right public/private keys, and the public one registered to GitHub)

# print subdirectories recursively
  find /path/to/folder -type d -print

# mv
  mv -fv /path/to/file /path/to/folder/
  options:
    -f: do not prompt for confirmation before overwriting the destination path
    -v: be verbose, showing files after they are moved

# rm
  mv -rf /path/to/folder
  options:
    -f: do not prompt for confirmation before removing files
    -r: be recursive

# skeleton files for bash environment: (.bash_profile and .bashrc)
  /etc/skel/.bash_profile
  /etc/skel/.bashrc
  /etc/skel/.bash_logout

# locale: Get locale-specific information

# configure, make, make install
 1) configure: preparation of building the software on your specific system, making sure
    that all the dependencies for the rest of the build and install process are available, and
    finding out whatever it needs to know to use those dependencies
 2) make: runs a series of tasks defined in a Makefile to build the program from its source code
 3) make install: once the software is built and ready to run, the files need to be copied to
    their final destination, so make install will copy the built program and its libraries and
    documentations to the correct locations

# make
  make -C [dir] [target]
  options:
    -C: change to directory dir before reading the makefiles or doing  anything
  ex. make -C dir html ==> cd dir; make html

# uname -a: find out whether the system is 32 or 64 bit
  find out which operating system is running on in UNIX

# /proc/cpuinfo: find cpu information os the system
  cat /proc/cpuinfo

# run a process in background, foreground, and kill it 
  ./prog1 &     ==> run in background
  fg [JobId]    ==> bring to foreground
  kill -9 [PID] ==> kill a process
    signals: 9  ==> KILL, non-catchable, non-ignorable kill
             15 ==> TERM, software termination signal (default)

# suspend process:
  CTRL + z to suspend running process and fg 1, fg 2 to bring it on foreground

# execute previous commands:
  1) !"cmd": execute last command of cmd
  ex.
    vim filename
    !vim     ==> executes last vim command
  ex.
    ls -lrt
    !ls      ==> executes last ls command
  2) !!: execute last command
  3) CRTL + r and type command initials
  4) history | grep command

# move across directories:
  ex.
    cd ~       ==> move to home directory
    cd -       ==> move to previous directory

