# create virtualenv
  virtualenv --python=/usr/local/bin/python3.5 myproject
  source myproject/bin/activate
  pip install <python_pkg> 

# pip commands
  pip search <pkg_name>: search PyPI for packages
  pip show <pkg_name>: show information about installed packages
  pip list: list installed packages
  pip install <pkg_name>: install a single package
  pip install <pkg_name>==<version>: install a single package with a specific version
    ex. pip install django_modeltranslation==0.4.0
  pip freeze > requirements.txt
    output a package manifest to the terminal (requirements.txt should have specific versions for each package)
    ex.
      Django==1.7.11
      mysqlclient==1.3.7
  pip install -r requirements.txt
    install a list of packages possibly with version requirements needed to create a working application environment

# setup.py
  ex.
  from setuptools import setup
  setup(
       name="yahoo.contrib.project",
       scripts=['scripts/program1.py', 'scripts/program2.py'], # will be put in user bin folder
       install_requires = [                                    # all dependencies listed in the install_requires will be installed when the package is installed
            'requests',
            'django>=1.7',
            'django-redis-cache',
            'django-rest-framework',
            'redislite'
       ]
  )

# difference with install_requires setting in the setup.py: no package versions in the install_requires
  install_requires: abstract dependencies, i.e. the minimal dependencies needed for the package to function
  requirements.txt: concrete dependencies, i.e. needed to create a specific application environment
    this file contains any "optional" package requirements needed to create the environment as well as packages that are dependencies of other packages that are being used

# virtualenv use case
  virtualenv --python=/usr/local/bin/python3.5 myproject
  source myproject/bin/activate
  pip install -r requirements.txt

# str type vs unicode type
  1) str: a plain sequence of bytes (in Python3, str is called bytes)
  2) unicode: a general representation of some text, which can be encoded in many different ways
     (text is a sequence of code points which may be bigger than a single byte)
  3) literal strings are unicode by default in Python3, i.e. unicode of Python2 is equivalent to str in Python3
  ex.
    >>> text = 'รก'     <== unicode string in Python3, i.e. text = u'รก'
    >>> len(text)   
        1              <== one code point
    >>> text.encode('utf8')
        b'\xc3\xa1'    <== bytes literal 

