# shebang: #!/bin/bash"
  the script is to be executed by /bin/bash
  ("#" is called hash and "!" is called bang)

# two types of variables
  1) environment variables (system-defined variables):
     ex. echo $PATH
  2) shell local variables (user-defined variables):
     ex. var=1
         echo $var
  ("set" can display all shell local variables and environment variables, whereas "env" cannot)
  (use "export" to export var to environment variables)

# variable substitution
  var=value  ==> set var to a value (note: no spaces are allowed before and after "=")
    ex.
      var1=123
      var2=oneTwoThree
  var:=value ==> use var if set; otherwise, use value and assign value to var

# default variables 
  $?: whether the previous command is executed successfully (0: successful)
      (i.e. the exit status of the previous command)
  other special variables:
  $0: name of the script
  $1: 1st argument
  $2: 2nd argument
  $#: number of arguments
  $@: an array-like construct of all positional parameters, { $1, $2, $3, ... }
  $*: all arguments separated with spaces, $1 $2 $3 ...
  $$: PID of current shell (not subshell)
  $!: PID of the most recent background command

# unset or de-assign a variable
  unset variable_name

# how to read input from terminal?
  ex.
    echo "Input value for variable a"
    read a
  or
    read -p "Input value for variable a: " a
    echo "variable a is $a"

# quotes in shell
  1) weak quotes: "..."
    echo "print out the value of $var"
  2) strong quotes: '...'
    echo 'print out $var literally'
  3) command substitution: `command` or $(command)
    echo `pwd` or echo $(pwd)
    sudo chown `id -u` /folder_name  ==> sudo chown 1000 /folder_name (ex. user id == 1000)

# redirect both stdout and stderr to the same location
  method 1: 2>&1
      ex. ls -l > output 2>&1
  method 2: &>
      ex. ls -l &> output
  (handle 0: stdin, 1: stdout, 2: stderr)

# error redirection (file descriptor: 0: stdin, 1: stdout, 2: stderr)
  ex.
    du -sh 2>err_file
    du -sh 2>/dev/null (redirect "... Permission denied ..." error to /dev/null)

# compare numbers
  -eq: equal
  -ne: not equal
  -gt: greater than
  -lt: less than
  -ge: greater than or equal
  -le: less than or equal

  ex.
  x=10              <==== there cannot be spaces surrounding = (i.e. no x_=_10)
  y=20              <==== there cannot be spaces surrounding = (i.e. no y_=_10)
  if [ $x -gt $y ];  <==== use $variable_name to access variable
  then
      echo "x > y";
  else
      echo "x <= y";
  fi

# perform arithmetic operation
  a=`expr 5 + 2`   ==> "+" in 5_+_2 must be surrounded by spaces
                               `expr ...` is needed as expr is a command
  a=$[ 16 + 4 ]    ==> $[ expression ] is an alternative way of arithmetic operation

# compare strings
  test str1 == str2: equal (there must be spaces surrounding _==_)
  test str1 != str2: not equal (there must be spaces surrounding _!=_)
  test -z str: empty string
  test -n str (test str): not empty string (-n can be omitted)

  ex.
  str1="abc"
  str2="abc"
  test $str1 == $str2 && echo "str1 equals str2"

# test files
  test -e filename: does filename exist?
  test -f filename: is a file?
  test -d filename: is a directory?
  test -r filename: readable?
  test -w filename: writable?
  test -x filename: executable?
  test -s filename: file not empty?

# test command
  test -s filename: test if filename exists and has a size greater than zero
  test -S filename: test if filename exists and is a socket
  test -s filename || { echo "filename does not exist! Exiting..."; exit 1; }
    test if the non-empty filename exists; otherwise, print error message and exit with 1

# how to define function?
  function_name()
  {
      commands
  }

  ex.
  func()
  {
      read -p "input a number: " var
      echo "the input number is $var"
  }
  func  <== execute func

# nested if statement
  if [ condition ];  <==== [_condition_] must have spaces surrounding condition
  then              <==== must be put in a distinct line (cannot be put after the if-statement)
      command1;
      command2;
  else              <==== must be put in a distinct line
      if [ condition ];
      then
          command3;
      else
          command4;
      fi
  fi                <==== must be put in a distinct line

# the while-loop statement
  while [ condition ];
  do
      command;
  done

# the for-loop statement
  for var in value1 value2 value3;
  do
      command;
  done

  ex.
  for a in dog cat tiger;
  do
      echo "$a";
  done

# the switch statement
  case $var in
  value1)
      command1
      command2
      ;;
  value2)
      command3
      command4
      ;;
  *)
      command5
      ;;
  esac

  ex.
  a=5
  case $a in
  1)
      echo "$a == 1"
      ;;
  2)
      echo "$a == 2"
      ;;
  *)
      echo "$a != 1 and $a != 2"
      ;;
  esac

