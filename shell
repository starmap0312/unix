# shebang: #!/bin/bash"
  the script is to be executed by /bin/bash
  ("#" is called hash and "!" is called bang)

# two types of variables
  1) environment variables (system-defined variables):
     ex. echo $PATH
  2) shell local variables (user-defined variables):
     ex. var=1
         echo $var
  ("set" can display all shell local variables and environment variables, whereas "env" cannot)
  (use "export" to export var to environment variables)

# set
  set -e: enables checking of all commands
    if a command exits with an error and the caller does not check such error, then the scripts 
    aborts immediately
  set -x: trace the execution of all commands
    make the interpreter print each command right before it is executed

# variable substitution
  var=value  ==> set var to a value (note: no spaces are allowed before and after "=")
    ex.
      var1=123
      var2=oneTwoThree
  echo ${var:=value} ==> use var if set; use new value if undefined, and redefine

# Makefile variable assignment
  1) Lazy Set: value is expanded when the variable is used, not when it is declared
     VARIABLE = value
  2) Immediate Set: value is expanded when the variable is declared
     VARIABLE := value
  3) Set If Absent: set variable only when it is undefined (do nothing if it already has a value)
     VARIABLE ?= value
  4) Append: append the value to the existing value (simply set the variable if it is undefined)
     VARIABLE += value

# default variables 
  $?: whether the previous command is executed successfully (0: successful)
      (i.e. the exit status of the previous command)
  other special variables:
  $0: name of the script
  $1: 1st argument
  $2: 2nd argument
  $#: number of arguments (ex. script_name 1 2 3, then $# == 3)
    ex. if [ $# != 3 ]; then echo usage; fi
  $@: an array-like construct of all positional parameters, { $1, $2, $3, ... }
  $*: all arguments separated with spaces, $1 $2 $3 ...
  $$: PID of current shell (not subshell)
  $!: PID of the most recent background command

# unset or de-assign a variable
  unset variable_name

# how to read input from terminal?
  ex.
    echo "Input value for variable a"
    read a
  or
    read -p "Input value for variable a: " a
    echo "variable a is $a"

# quotes in shell
  1) weak quotes: "..."
    echo "print out the value of $var"
  2) strong quotes: '...'
    echo 'print out $var literally'
  3) command substitution: `command` or $(command)
    echo `pwd` or echo $(pwd)
    sudo chown `id -u` /folder_name  ==> sudo chown 1000 /folder_name (ex. user id == 1000)

# redirect both stdout and stderr to the same location
  method 1: 2>&1
      ex. ls -l > output 2>&1
          yum install [pkg_name] 2>&1 > inst.log (redirect stdout/stderr message to a file)
  method 2: &>
      ex. ls -l &> output
  (handle 0: stdin, 1: stdout, 2: stderr)

# error redirection (file descriptor: 0: stdin, 1: stdout, 2: stderr)
  ex.
    du -sh 2>err_file
    du -sh 2>/dev/null (redirect "... Permission denied ..." error to /dev/null)

# compare numbers
  -eq: equal
  -ne: not equal
  -gt: greater than
  -lt: less than
  -ge: greater than or equal
  -le: less than or equal

  ex.
  x=10              <==== there cannot be spaces surrounding = (i.e. no x_=_10)
  y=20              <==== there cannot be spaces surrounding = (i.e. no y_=_10)
  if [ $x -gt $y ];  <==== use $variable_name to access variable
  then
      echo "x > y";
  else
      echo "x <= y";
  fi

  ex.
  if [ $? -ne 0 ];
  then
      echo last command failed
  fi

# perform arithmetic operation
  a=`expr 5 + 2`   ==> "+" in 5_+_2 must be surrounded by spaces
                               `expr ...` is needed as expr is a command
  a=$[ 16 + 4 ]    ==> $[ expression ] is an alternative way of arithmetic operation

# compare strings
  test str1 == str2: equal (there must be spaces surrounding _==_)
  test str1 != str2: not equal (there must be spaces surrounding _!=_)
  test -z str: empty string
  test -n str (test str): not empty string (-n can be omitted)

  ex.
  str1="abc"
  str2="abc"
  test $str1 == $str2 && echo "str1 equals str2"

  ${#str1} ==> get string length, i.e. 3

# extract substring
  ${string:position:length}
  ex.
    var=12345
    echo ${var:2:2} ==> 34

# test files
  test -e filename: does filename exist? i.e. [ -f filename ]
    ex. [ -f /etc/hosts ] && echo "Found" || echo "Not found"
  test -f filename: is a file?
  test -d filename: is a directory?
  test -r filename: readable?
  test -w filename: writable?
  test -x filename: executable?
  test -s filename: file not empty?

  if [ -r /path/to/file ]; then do_something; fi

# test command
  test -s filename: test if filename exists and has a size greater than zero
  test -S filename: test if filename exists and is a socket
  test -s filename || { echo "filename does not exist! Exiting..."; exit 1; }
    test if the non-empty filename exists; otherwise, print error message and exit with 1

# how to define function?
  function_name()
  {
      commands
  }

  ex.
  func()
  {
      read -p "input a number: " var
      echo "the input number is $var"
  }
  func  <== execute func

# nested if statement
  if [ condition ];  <==== [_condition_] must have spaces surrounding condition
  then              <==== must be put in a distinct line (cannot be put after the if-statement)
      command1;
      command2;
  else              <==== must be put in a distinct line
      if [ condition ];
      then
          command3;
      else
          command4;
      fi
  fi                <==== must be put in a distinct line

# the while-loop statement
  while [ condition ];
  do
      command;
  done

# the for-loop statement
  for var in value1 value2 value3;
  do
      command;
  done

  ex.
  for a in dog cat tiger;
  do
      echo "$a";
  done

  ex.
  for i in `seq 1 10`;
  do
      echo $i;
  done

  ex.
  START=3
  END=7
  for i in $(seq $START $END);
  do
      echo $i;
  done

# the switch statement
  case $var in
  value1)
      command1
      command2
      ;;
  value2)
      command3
      command4
      ;;
  *)
      command5
      ;;
  esac

  ex.
  a=5
  case $a in
  1)
      echo "$a == 1"
      ;;
  2)
      echo "$a == 2"
      ;;
  *)
      echo "$a != 1 and $a != 2"
      ;;
  esac

# debugging bash scripts
  bash -x /path/to/script
    -x: run the entire script in debug mode. traces of each command plus its arguments are
        printed to stdout

# xargs: build and execute command lines from standard input
  find /path/to/folder -perm -700 | xargs ls -l
    (find files with permissions at least 700 and perform ls -l to them)
  find . -mtime +15 -type f | xargs -i <cmd> {}
  find . -mtime +15 -type f | xargs -i ls -alh {}
    -i[replace-str]: i.e. -I{} (default)
  rpm -ql yum | xargs -I {} sh -c 'test -f {} && echo {}'
    (note: rpm -ql yum | xargs -I {} test -f {} && echo {} does not work)
    sh -c string: commands are read from string (sh: bash)
  
# double-dash
  a double dash (--) is used in bash built-in commands to signify the end of command options
    after which only positional parameters are accepted
  ex.
    grep -- -v filename ==> grep keyword "-v" (-- signify that -v is not an option for grep)
    
# =~: Equal Tilde operator
  1) allows the use of regex in an if statement
     the string to the right of the operator is considered an extended regular expression and matched accordingly
  2) the return value is 0 if the string matches the pattern, and 1 otherwise
  ex.
    [[ $date =~ ^[0-9]{4}(0[0-9]|1[0-2])([0-2][0-9]|3[0-1])$ ]] && echo "yes"
    #           |^^^^^^^^ ^^^^^^ ^^^^^^  ^^^^^^^^^^ ^^^^^^ |
    #           |   |         |                   |        |
    #           | year YYYY   |      either 00-29 or 30,31 |
    # start of line  either 0X or 10,11,12                end of line

# <<<: here string
  COMMAND <<<$WORD
  1) a stripped-down form of a here document
  2) the value of $WORD is expanded and fed to the stdin of COMMAND

    ex.
      a) if [[ $VAR = *txt* ]]; then do_something; fi
      b) if echo "$VAR" | grep -q txt; then do_something; fi
      c) if grep -q "txt" <<< "$VAR"; then do_something; fi

    ex.
      wc -w <<< "This is a test."
      output: 4

    ex. grepping into a shell variable
      var="Neither in this world nor elsewhere is there any happiness in store for him who always doubts."
     
      grep "nor" $var (WRONG)
      output: grep: Neither: No such file or directory

      grep "nor" <<<$var >/dev/null && echo "Found" || echo "Not found" 
      output: Found

      alternatively: use shell pipes to grep into $var
      echo $var | grep -q "nor"  && echo "Found" || echo "Not found"

   ex. Counting network interfaces
     wc -w <<<$(netstat -i | cut -d" " -f1 | egrep -v "^Kernel|Iface|lo")
     output: 3

     wc <<< $(cat filename)
     output: 1    1374    7571
     i.e. cat filename | wc

# Shell Arrays
  1) Defining Array Values:
     array_name[index]=value
     ex.
       NAME[0]="Zara"
       NAME[1]="Qadir"
       NAME[2]="Mahnaz"
     in bash: array_name=(value1 ... valuen) 
     ex.
       NAME=("Zara" "Qadir" "Mahnaz")
  2) Accessing Array Values: ${array_name[index]}
     ex.
       echo ${NAME[0]}
       echo ${NAME[1]}
       echo ${NAME[2]}
  3) access all the items in an array
     ${array_name[*]}
     ${array_name[@]}

# shell options
  myArray=( "$@" )  ==> assign all positional parameters, { $1, $2, $3, ... }, to an array

  shift command: (in bash)
    shift [N]: the positional parameters are shifted to the left by N
    i.e. shift
         the positional parameters $1 - $# are renamed:
         before: $1, $2, $3, ..., $#
         after:      $1, $2, ..., $# ($# is decremented by one)

  ex. read in options by while-loop and shift command:

  while test "$1"; do     ==> if "$1" is not empty
      case "$1" in
          --help)         echo "usage"; exit 0;;
          --version)      echo "version"; exit 0;;
          --)             shift; break;;
          *)              break
      esac
      shift
  done

  test "$1" || {
      echo "need more options"
      exit 1
  }


  ex. read in options by a for-loop

  for arg in "$@" ; do
      case "$arg" in
          http://*|https://*|ftp://*)  => read http://, https://, ftp://
              do_something;
              ;;
          *.[rs]pm)                    => read *.rpm, *.spm
              do_something;
              ;;
          *)
              do_something;
      esac
  done
  
# concatenate the values of an array to a string
  for arg in "${myArray[@]}"; do
      options="$options $arg"
  done

